'use strict';

var PromiseA = require('bluebird');
var EventEmitter = require('events').EventEmitter;
var natSsdp = require('./ssdp');
var natDevice = require('./device');

function Client(opts) {
  if (!opts) {
    opts = {};
  }

  this._opts = opts;
}
Client.create = function create(opts) {
  var client = new Client(opts);

  return client.init().then(function () {
    return client;
  });
};

Client.prototype.init = function () {
  var self = this;

  return natSsdp.create(this._opts).then(function (ssdp) {
    self.ssdp = ssdp;
  });
};



function normalizeOptions(options) {
  function toObject(addr) {
    if (typeof addr === 'number') { return { port: addr }; }
    if (typeof addr === 'object') { return addr; }

    return {};
  }

  return {
    remote: toObject(options.public),
    internal: toObject(options.private)
  };
}

Client.prototype.portMapping = function portMapping(options, callback) {
  return this.findGateway().then(function(stuff) {
    if (options.debug) {
      console.log('[upnp] DEBUG found gateway', stuff);
    }

    return new PromiseA(function (resolve, reject) {
      var ports = normalizeOptions(options);
      var args = [
        [ 'NewRemoteHost', ports.remote.host ],
        [ 'NewExternalPort', ports.remote.port ],
        [ 'NewProtocol', options.protocol ?
            options.protocol.toUpperCase() : 'TCP' ],
        [ 'NewInternalPort', ports.internal.port ],
        [ 'NewInternalClient', ports.internal.host || stuff.address ],
        [ 'NewEnabled', 1 ],
        [ 'NewPortMappingDescription', options.description || 'node:nat:upnp' ],
        [ 'NewLeaseDuration', typeof options.ttl === 'number' ?
            options.ttl : 60 * 30 ]
      ];

      if (options.debug) {
        console.log('[upnp] DEBUG nat-upnp AddPortMapping:');
        console.log(args);
      }

      stuff.gateway.run('AddPortMapping', args, function (err, data) {
        if (options.debug) {
          console.log('[upnp] DEBUG nat-upnp', err, data);
        }

        if (err) {
          reject(err);
          return;
        }

        if (callback) { callback(null, data); }
        resolve(data);
      });
    });
  }).catch(function (err) {
    if (callback && callback.arity) {
      callback(err);
      return;
    }

    throw err;
  });
};

Client.prototype.portUnmapping = function portUnmapping(options, callback) {
  if (!callback) {
    callback = function() {};
  }

  return this.findGateway(function(err, gateway/*, address*/) {
    if (err) { return callback(err); }

    var ports = normalizeOptions(options);

    return new PromiseA(function (resolve, reject) {
      gateway.run('DeletePortMapping', [
        [ 'NewRemoteHost', ports.remote.host ],
        [ 'NewExternalPort', ports.remote.port ],
        [ 'NewProtocol', options.protocol ?
            options.protocol.toUpperCase() : 'TCP' ]
      ], function (err, data) {
        if (err) {
          reject(err);
          return;
        }

        if (callback) {
          callback(null, data);
        }
        resolve(data);
      });
    });
  }).catch(function (err) {
    if (callback && callback.arity) {
      callback(err);
      return;
    }

    throw err;
  });
};

Client.prototype.getMappings = function getMappings(options, callback) {
  var emitter = new EventEmitter();

  // TODO needs event emitter!
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!options) { options = {}; }

  this.findGateway().then(function(stuff) {
    var results = [];

    function getMappingEntry(i) {
      return new PromiseA(function (resolve/*, reject*/) {
        stuff.gateway.run('GetGenericPortMappingEntry', [
          [ 'NewPortMappingIndex', i ]
        ], function(endOfListError, data) {
          if (endOfListError) {
            // this error simply means we've failed to get i + 1,
            // which most likely means a normal end of the list result
            resolve(false);
            return;
          }

          var key;
          Object.keys(data).some(function(k) {
            if (!/:GetGenericPortMappingEntryResponse/.test(k)) { return false; }

            key = k;
            return true;
          });
          data = data[key];

          var result = {
            public: {
              host: typeof data.NewRemoteHost === 'string' &&
                    data.NewRemoteHost || '',
              port: parseInt(data.NewExternalPort, 10)
            },
            private: {
              host: data.NewInternalClient,
              port: parseInt(data.NewInternalPort, 10)
            },
            protocol: data.NewProtocol.toLowerCase(),
            enabled: data.NewEnabled === 1,
            description: data.NewPortMappingDescription,
            ttl: parseInt(data.NewLeaseDuration, 10)
          };
          result.local = result.private.host === stuff.iface;

          resolve(result);
        });
      });
    }

    function endLoop(results) {
      emitter.emit('end');
      if (callback) {
        callback(null, results);
      }
    }

    function completeAll(results) {
      if (!results) {
        endLoop();
        return;
      }

      if (options.local) {
        results = results.filter(function(item) {
          return item.local;
        });
      }

      if (options.description) {
        results = results.filter(function(item) {
          if (options.description instanceof RegExp) {
            return item.description.match(options.description) !== null;
          } else {
            return item.description.indexOf(options.description) !== -1;
          }
        });
      }

      emitter.emit('results', results);
      endLoop(results);
    }

    function getMappingEntries(i) {
      return getMappingEntry(i).then(function (entry) {
        if (!entry) {
          return results;
        }

        if (emitter._stop) {
          return;
        }

        results.push(entry);
        // Shim this as 0-indexed
        emitter.emit('entry', entry, i - 1);
        return getMappingEntries(i + 1);
      });
    }

    // start the mapped entries at index 1
    // (kinda odd place to start, huh? must be lua devs writing the spec...)
    return getMappingEntries(1).then(completeAll);
  }).catch(function (err) {
    if (callback && callback.arity) {
      callback(err);
      return;
    }

    throw err;
  });

  // TODO maybe this should be end() or close()
  emitter.cancel = function () {
    emitter._stop = true;
  };

  // This makes sense as an emitter,
  // but it also makes sense as a promise
  emitter._promises = [];
  emitter.then = function (fn) {
    emitter._promises.push(fn);
    return emitter;
  };
  emitter.on('results', function (results) {
    emitter._results = results;
  });
  emitter.on('end', function () {
    emitter._promises.forEach(function (fn) {
      fn(emitter._results);
    });
  });

  return emitter;
};

Client.prototype.externalIp = function externalIp(callback) {
  return this.findGateway(function(err, gateway/*, address*/) {
    if (err) {
      callback(err);
      return;
    }

    gateway.run('GetExternalIPAddress', [], function(err, data) {
      if (err) {
        callback(err);
        return;
      }

      var key;

      Object.keys(data).some(function(k) {
        if (!/:GetExternalIPAddressResponse$/.test(k)) { return false; }

        key = k;
        return true;
      });

      if (!key) {
        err = new Error('Incorrect response');
        err.body = data;
        callback(err);
        return;
      }

      callback(null, data[key].NewExternalIPAddress);
    });
  });
};

Client.prototype.findGateway = function findGateway(callback) {
  var p;

  p = this.ssdp.search(
    'urn:schemas-upnp-org:device:InternetGatewayDevice:1',
    { timeout: this.timeout }
  ).then(function (stuff) {
    stuff.gateway = natDevice.create(stuff.headers.location);

    if (callback) {
      callback(null, stuff.gateway, stuff.iface);
    }

    return stuff;
  }).catch(function (err) {
    if (callback && callback.arity) {
      callback(err);
      return;
    }

    throw err;
  });

  return p;
};

module.exports.create = Client.create;
module.exports.Client = Client.Client = Client;
module.exports = Client;

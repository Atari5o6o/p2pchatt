'use strict';

var PromiseA = global.Promise || require('bluebird').Promise;
var dgram = require('dgram');
var os = require('os');

function Ssdp(opts) {
  this._opts = opts || {};

  this._multicast = '239.255.255.250';
  this._port = 1900;
  this._closed = false;
  this._queue = [];
  this._devicePromise = {};
  this._sockets = [];

  this._sourcePort = this._opts.sourcePort || 0;
  this._timeout = this._opts.timeout || 1800;
}

Ssdp.create = function create(opts) {
  var ssdp = new Ssdp(opts)
    ;

  return PromiseA.resolve(ssdp);
  /*
  return ssdp.init().then(function () {
    return ssdp;
  });
  */
};

Ssdp.prototype.init = function () {
  // Create sockets on all external interfaces
  return this.createSockets();
};

Ssdp.parseMimeHeader = function (headerStr) {
  var lines = headerStr.split(/\r\n/g);

  // Parse headers from lines to hashmap
  return lines.reduce(function(headers, line) {
    line.replace(/^([^:]*)\s*:\s*(.*)$/, function (a, key, value) {
      headers[key.toLowerCase()] = value;
    });
    return headers;
  }, {});
};

Ssdp.prototype.createSockets = function createSockets() {
  if (this._boundPromise) {
    return this._boundPromise;
  }

  var self = this;
  var promises = [];
  var interfaces = os.networkInterfaces();

  Object.keys(interfaces).forEach(function(key) {
    return interfaces[key].filter(function(iface) {
      // don't include localhost and (non-external) virtual interfaces
      return !iface.internal && !/^fe80/.test(iface.address);
    }).forEach(function(iface) {
      var socket = dgram.createSocket(iface.family === 'IPv4' ?
            'udp4' : 'udp6');
      var promise;

      promise = Ssdp._initSocket(socket, self._sourcePort, iface.address);
      promises.push(promise);
      promise.then(function (socket) {
        self._sockets.push(socket);
      }).catch(function (err) {
        self._sockets.splice(self._sockets.indexOf(socket), 1);
        throw err;
      });
    });
  });

  // forEachAsync would normally be better, but for such a small number of
  // sockets (usually 1 or 2 dozens, at max, never hundreds) .all() works
  self._boundPromise = PromiseA.all(promises);
  return self._boundPromise;
};

Ssdp.prototype.search = function search(deviceStr/*, opts*/) {
  if (this._devicePromise[deviceStr]) {
    return this._devicePromise[deviceStr];
  }
  // if (!opts) opts = {};

  var self = this;

  return self.init().then(function () {
    return self._boundPromise.then(function () {
      var promise
        ;

      // I'm in favor of returning as many gateways as respond, but we'll
      // do just one for now, for the sake of backwards compat and simplicity
      promise = new PromiseA(function (resolve, reject) {
        var query;
        var timeoutToken;

        query = new Buffer(
          'M-SEARCH * HTTP/1.1\r\n' +
          'HOST: ' + self._multicast + ':' + self._port + '\r\n' +
          'MAN: "ssdp:discover"\r\n' +
          'MX: 1\r\n' +
          'ST: ' + deviceStr + '\r\n' +
          '\r\n'
        );

        function closeAll() {
          self._closed = true;
          setTimeout(function () {
            self._devicePromise[deviceStr] = null;
            // TODO no magic numbers
          }, 5 * 60 * 1000);
          resolve = function () {};
          clearTimeout(timeoutToken);
          // shallow copy the array
          // (as not to modify the original during the loop)
          self._sockets.slice(0).forEach(function (socket) {
            // socket.close() should prevent any further 'message' events
            // (i.e. ones already in the queue), but I can't remember, so
            // self._closed is a secondary gaurd.
            socket.close();
            self._sockets.splice(self._sockets.indexOf(socket), 1);
          });
        }

        timeoutToken = setTimeout(function () {
          closeAll();
          reject(new Error('\'SSDP timeout while searching for \'' +
            deviceStr + '\''));
        }, self._timeout);

        // Send query on each socket
        self._sockets.forEach(function (socket) {
          function resolveIfDeviceReplies(message, info) {
            // Ignore messages after closing sockets
            if (self._closed) { return; }

            var headers
              ;

            // Parse response
            headers = Ssdp._parseResponse(
              message.toString(),
              socket.address,
              info
            );
            if (!headers) { return; }
            // perchance we somehow get a message from another device
            // (perhaps a late response)
            if (headers.st !== deviceStr) { return; }

            resolve({
              headers: headers,
              remote: info,
              address: socket.address,
              iface: socket.address
            });
            closeAll();
          }
          socket.on('message', resolveIfDeviceReplies);
          socket.send(query, 0, query.length, self._port, self._multicast);
        });
      });

      self._devicePromise[deviceStr] = promise;

      return promise;
    });
  });
};

Ssdp._initSocket = function initSocket(socket, port, address) {
  // TODO
  // I think it would be better to do this more lazily
  // (i.e. only just before a call to .send)
  return new PromiseA(function (resolve, reject) {
    socket.once('listening', function() {
      resolve(socket);
    });

    // On error - remove socket from list and execute items from queue
    socket.once('error', function(err) {
      reject(err);
    });

    socket.port = port;
    socket.address = address;
    socket.bind(port, address);

    return socket;
  });
};

// TODO create separate logic for parsing unsolicited upnp broadcasts,
// if and when that need arises
Ssdp._parseResponse = function parseResponse(response) {
  // Ignore incorrect packets
  if (!/^(HTTP|NOTIFY)/m.test(response)) { return; }

  var headers = Ssdp.parseMimeHeader(response);

  // We are only interested in messages that can be matched against
  // the original search target
  if (!headers.st) { return; }

  return headers;
};

module.exports = Ssdp.Ssdp = Ssdp;
